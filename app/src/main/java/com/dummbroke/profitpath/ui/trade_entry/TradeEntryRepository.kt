package com.dummbroke.profitpath.ui.trade_entry

import android.app.Application
import android.net.Uri
import android.os.Environment
import com.dummbroke.profitpath.core.models.Trade
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.Timestamp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.UUID

class TradeEntryRepository(
    private val application: Application,
    private val firestore: FirebaseFirestore,
    private val auth: FirebaseAuth
) {

    suspend fun saveTrade(trade: Trade, imageUri: Uri?): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid
            if (userId == null) {
                return@withContext Result.failure(Exception("User not logged in"))
            }
            trade.userId = userId
            trade.lastUpdated = Timestamp.now() // Set last updated time as Firestore Timestamp

            // Handle image saving
            if (imageUri != null) {
                val imagePath = saveImageToLocalStrong(userId, imageUri)
                if (imagePath != null) {
                    trade.screenshotPath = imagePath
                } else {
                    // Optionally, decide if failing to save image is a critical error
                    // return@withContext Result.failure(Exception("Failed to save screenshot"))
                }
            }

            // Add to Firestore
            // The document ID will be auto-generated by Firestore
            firestore.collection("users").document(userId)
                .collection("trades")
                .add(trade)
                .await() // Wait for the operation to complete

            // If newBalanceAfterTrade is set and balanceUpdated is true, update profile too
            if (trade.balanceUpdated && trade.newBalanceAfterTrade != null) {
                 firestore.collection("users").document(userId)
                    .collection("profile").document("account_summary") // Assuming a single doc for summary
                    .update("currentBalance", trade.newBalanceAfterTrade)
                    .await()
            }

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    private fun saveImageToLocalStrong(userId: String, sourceUri: Uri): String? {
        return try {
            val contentResolver = application.contentResolver
            val inputStream = contentResolver.openInputStream(sourceUri) ?: return null

            // Create a unique filename
            val timeStamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
            val imageFileName = "JPEG_${userId}_${timeStamp}_${UUID.randomUUID()}.jpg"

            // Get the app-specific directory for pictures
            // Path: /storage/emulated/0/Android/data/com.dummbroke.profitpath/files/Pictures/TradingJournal/screenshots/{userId}
            val userScreenshotsDir = File(
                application.getExternalFilesDir(Environment.DIRECTORY_PICTURES),
                "TradingJournal/screenshots/$userId"
            )

            if (!userScreenshotsDir.exists()) {
                userScreenshotsDir.mkdirs()
            }

            val imageFile = File(userScreenshotsDir, imageFileName)
            val outputStream = FileOutputStream(imageFile)

            inputStream.use { input ->
                outputStream.use { output ->
                    input.copyTo(output)
                }
            }
            imageFile.absolutePath
        } catch (e: Exception) {
            // Log error e.printStackTrace() or Timber.e(e, "Error saving image")
            null
        }
    }

    suspend fun updateProfileBalanceWithTrade(pnlAmount: Double) = withContext(Dispatchers.IO) {
        val userId = auth.currentUser?.uid ?: return@withContext
        val profileDoc = firestore.collection("users")
            .document(userId)
            .collection("profile")
            .document("user_profile_data")
        val snapshot = profileDoc.get().await()
        val currentBalance = snapshot.getDouble("currentBalance") ?: 0.0
        val newBalance = currentBalance + pnlAmount
        profileDoc.update("currentBalance", newBalance).await()
    }

    suspend fun updateTrade(tradeId: String, trade: Trade, imageUri: Uri?): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid
            if (userId == null) {
                return@withContext Result.failure(Exception("User not logged in"))
            }
            trade.userId = userId
            trade.lastUpdated = Timestamp.now()

            // Handle image updating
            if (imageUri != null) {
                val imagePath = saveImageToLocalStrong(userId, imageUri)
                if (imagePath != null) {
                    trade.screenshotPath = imagePath
                }
            } else {
                // If no new image, keep the existing screenshotPath (do not overwrite)
                val existingDoc = firestore.collection("users")
                    .document(userId)
                    .collection("trades")
                    .document(tradeId)
                    .get()
                    .await()
                val existingTrade = existingDoc.toObject(Trade::class.java)
                if (existingTrade != null && !existingTrade.screenshotPath.isNullOrBlank()) {
                    trade.screenshotPath = existingTrade.screenshotPath
                }
            }

            firestore.collection("users").document(userId)
                .collection("trades").document(tradeId)
                .set(trade)
                .await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
} 